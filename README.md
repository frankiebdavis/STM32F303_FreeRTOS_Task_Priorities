# ğŸ§  FreeRTOS Task Scheduling Demo â€“ STM32F303RE

This project demonstrates how **FreeRTOS** enables multitasking on the STM32F303RE Nucleo board. It highlights how task priorities and scheduling policies can be used to control task behavior â€” something that isn't possible with traditional sequential microcontroller code.

Whether you're building real-time systems or trying to improve embedded firmware structure, this project serves as a practical showcase of why RTOS-based development is a step above bare-metal looping.

---

## ğŸ¯ Project Goal

To demonstrate how FreeRTOS enables:

- Cooperative multitasking using delays
- Controlled task scheduling through priority settings
- Task management features like runtime termination

---

## ğŸ”§ Hardware Used

- STM32F303RE Nucleo Board  
- USB cable for power/debug (ST-Link interface)  
- Host PC running STM32CubeIDE  

---

## ğŸš¦ What This Project Does

This demo uses **two FreeRTOS tasks**, `Task1` and `Task2`, that each print a line to the debug console. Depending on how task priorities are configured or modified, the output behavior changes.

The output is captured using **ITM/SWO print debugging** â€” viewable in STM32CubeIDE under the SWV ITM Console.

---

## ğŸ“Š Demo Scenarios

### âœ… 1. **Default: Task1 Runs First**
- `Task1`: priorityNormal  
- `Task2`: priorityLow

ğŸ” Output:
```
Task 1
Task 2
Task 1
Task 2
...
```

This shows how higher-priority tasks preempt lower ones, but both still share time via `osDelay()`.

---

### âœ… 2. **Priority Flip: Task2 Runs First**
- `Task1`: priorityLow  
- `Task2`: priorityNormal

ğŸ” Output:
```
Task 2
Task 1
Task 2
Task 1
...
```

A simple priority change completely reverses the execution order â€” no changes needed to task logic itself.

---

### âœ… 3. **Task2 Terminates Task1**
Inside `Task2`, we call `osThreadTerminate(Task1Handle);` after the first round.

ğŸ” Output:
```
Task 1
Task 2
Task 2
Task 2
...
```

This demonstrates how FreeRTOS allows one task to control another â€” enabling dynamic behavior that isnâ€™t possible in a blocking `while(1)` loop model.

---

## ğŸ’» How It Works

Tasks are created in `main.c` using `osThreadNew()` with assigned priorities. Each task prints its name and delays for 1 second.

```c
Task1Handle = osThreadNew(StartTask1, NULL, &Task1_attributes);
Task2Handle = osThreadNew(StartTask2, NULL, &Task2_attributes);
```

Inside each task function:

```c
void StartTask1(void *argument) {
    for (;;) {
        printf("Task 1\n");
        osDelay(1000);
    }
}
```

```c
void StartTask2(void *argument) {
    for (;;) {
        printf("Task 2\n");
        osDelay(1000);
        osThreadTerminate(Task1Handle); // Terminates Task1 after the first run
    }
}
```

Output is printed over **ITM debug channel (SWO)** using `printf()` mapped to `ITM_SendChar()` via `syscalls.c`.

---

## ğŸ§  Why FreeRTOS?

This project highlights why using an RTOS like FreeRTOS provides major advantages:

| Feature                  | Bare-Metal | FreeRTOS |
|--------------------------|------------|----------|
| Multiple concurrent tasks | âŒ No       | âœ… Yes    |
| Task priority control     | âŒ No       | âœ… Yes    |
| Clean code organization   | âŒ Usually messy | âœ… Tasks stay modular |
| Runtime task termination  | âŒ Manual logic | âœ… Built-in |

Even with just two tasks, this project demonstrates how FreeRTOS gives you **greater control, flexibility, and maintainability** in embedded systems development.

---

## ğŸ“„ License

This project uses code generated by STM32CubeMX and may contain code under the STMicroelectronics license.

MIT License applies to all original contributions unless otherwise stated.
